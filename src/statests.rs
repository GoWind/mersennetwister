mod statests {
    use quickersort;
    // Calculate the chi-squared value for the sample from the rng
    pub fn rngchi(v: &Vec<f32>, b: u32) {
        let bins = bin(v, b);
        // now that we have 'binned' v into b bins 
        // calculate expected n*p(bin) for each bin
        
    }

    // split the vector v in bins such that items from the vector
    // are roughly distributed into the bins equitably
    pub fn bin(v: &Vec<f32>, bins: u32) -> Vec<u32> {
        let mut binv = Vec::new();
        let  mut vcopy = v.clone();

        let mut bincount = Vec::with_capacity(bins as usize);
        quickersort::sort_floats(&mut vcopy);
        for i in 0..bins+1 {
            bincount.insert(i as usize, 0);
        }
        let binsf32 = bins as f32;
        //replace this by calculating the max(vcopy) - min(copy) / bins+1
        let d = (vcopy[vcopy.len()-1] - vcopy[0]) / ((bins+1u32) as f32);
        println!("{}::{} d is {}", vcopy[0], vcopy[vcopy.len()-1], d);
        binv.push(vcopy[0]);
        for i in 1..bins+2 {
            binv.push(vcopy[0] + ((i as f32 * d)));
            println!("{}", vcopy[0] + ((i as f32) * d));
        }
        for item in v {
           let mut idx = bins+1;
           while item < &binv[idx as usize]  {
                idx = idx -1;
           }
           bincount[idx as usize] += 1;
        }
        bincount
    }

    #[cfg(test)]
    mod tests {
        use super::*;
        #[test]
        fn test_some_stuff () {
            let test_items = vec![0.8288964005871517, 0.8293930793545836, 0.8249526015995814, 0.20761318803935236, 0.40777251924989577, 0.7883199657473172, 0.658009801649616, 0.6964373353791048, 0.42734177626294223, 0.2935628844394029, 0.26985372325745194, 0.8431090094806831, 0.9842457000066517, 0.988589332091148, 0.1275609035806704, 0.00805658228693662, 0.483333129500375, 0.8604877353922807, 0.9518390281561392, 0.08520246606034587, 0.46600796749628204, 0.7903991125695619, 0.9807730848570492, 0.5117286699508546, 0.4373429870373141, 0.7842112776932664, 0.4181322710969365, 0.7797415031509983, 0.5477589879018905, 0.8998532138704334, 0.7591812364959328, 0.592716796453425, 0.60857684872651, 0.8280893639850172, 0.6432759335600546, 0.6876323105235089, 0.2709994446514231, 0.9523503966228859, 0.4918111028268465, 0.5222262283368763, 0.17606874255617078, 0.5070018543057464, 0.7592205951673932, 0.44997245196745417, 0.7847602847483514, 0.6264106201730228, 0.3444535771185385, 0.4975878877850476, 0.30271987139396717, 0.7505449717491769, 0.22172781564522415, 0.525484974418788, 0.3913800975889712, 0.7226402427096694, 0.5153860234662176, 0.5363130034662438, 0.4958344482828746, 0.47159135378090256, 0.8429312724497215, 0.1881705141760548, 0.5641371305607737, 8.200241297684485e-05, 0.7098315900173496, 0.6006097143803387, 0.9238391752879579, 0.3126936519746871, 0.6998086756778132, 0.7317040221773319, 0.2235907873840347, 0.224700429784929, 0.8970143025432846, 0.2054880322595688, 0.503331629946913, 0.3896676921690262, 0.5813026208214391, 0.003555021915219836, 0.5210203240297094, 0.6667247317785963, 0.9883246269132172, 0.7033834942973997, 0.12117755540584585, 0.8531975247252143, 0.4427251473663171, 0.9696166413047118, 0.5734090699064515, 0.8964431980644714, 0.8060661088824934, 0.5638902736275939, 0.6301498877088976, 0.15652891219130638, 0.7761715754391202, 0.5022267776873256, 0.6919139118884348, 0.8532439825030598, 0.39434859467497807, 0.20802299053774265, 0.41565740023102704, 0.9035566155093505, 0.09121553917033876, 0.286877078621115];
        let bins_count = bin(&test_items, 10);
        assert_eq!(bins_count, vec![5,  5, 10,  6, 11, 17,  9, 15, 10, 12]);
        }
    }
}
